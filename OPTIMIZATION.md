# Аналіз та оптимізація застосунку

В результаті аналізу кодової бази було виявлено кілька ключових зон, де можна оптимізувати продуктивність та структуру коду.

## 1. State Management (InventoryProvider)

### Проблема: Монолітний Context Value
У `providers/inventory-provider.tsx` (рядки 2050–2140) створюється один гігантський об'єкт `value` за допомогою `useMemo`.
- **Наслідок**: Будь-яка зміна навіть дрібного стану (наприклад, `onboardingStep` або `ignoreGarnish`) змінює посилання на весь об'єкт Context. Це призводить до перерендеру **всіх** компонентів, які використовують `useInventory()`, навіть якщо вони не залежать від цього конкретного стану.
- **Рішення**: Розділити `InventoryContext` на кілька частин: `InventoryDataContext`, `InventorySettingsContext` та `InventoryActionsContext`.

### Проблема: Втрата референційної цілісності `cocktailsWithRatings`
У рядках 781–801 список коктейлів перетворюється (map) при кожній зміні рейтингів.
- **Наслідок**: Навіть якщо змінився рейтинг одного коктейлю, створюється новий масив з новими об'єктами коктейлів. Це змушує всі списки (FlatList) перерендеритися повністю.
- **Рішення**: Зберігати рейтинги окремо і об'єднувати їх лише там, де це необхідно, або використовувати більш витончений механізм оновлення.

### Проблема: Відсутність Debouncing при збереженні
`persistInventorySnapshot` (рядки 697–699) викликається у `useEffect` на кожну зміну стану.
- **Наслідок**: При швидкому перемиканні інгредієнтів (наприклад, у Shaker) відбувається багато записів у файлову систему поспіль.
- **Рішення**: Додати `debounce` для операцій збереження.

---

## 2. Продуктивність Списків (CocktailsScreen / IngredientsScreen)

### Проблема: Нестабільні посилання на `availableIngredientIds`
У `CocktailsScreen` та `IngredientsScreen` компоненти рядків (`CocktailListRow`, `IngredientListItem`) отримують `availableIngredientIds`, який є об'єктом `Set`. При кожній зміні доступності інгредієнтів створюється новий `Set`.
- **Наслідок**: Функції `memo` (`areCocktailRowPropsEqual`, `areIngredientPropsEqual`) бачать зміну посилання і змушують **всі** рядки списку перерендеритися, навіть ті, яких зміна не стосується.
- **Рішення**: Передавати в рядки лише необхідні примітиви (наприклад, `isAvailable: boolean`) або використовувати стабільніший механізм перевірки.

---

## 3. Обчислювальні витрати в IngredientsScreen

### Проблема: Важкі ланцюжки `useMemo`
У `app/(tabs)/ingredients/index.tsx` (рядки 394–470) відбуваються обчислення кількості доступних коктейлів для кожного інгредієнта.
- **Наслідок**: Код кілька разів ітерує по всій колекції коктейлів (яка може бути великою) при кожній зміні стану. Хоча використовується `useTransition`, основний потік все одно навантажується.
- **Рішення**: Об'єднати ці ітерації в один прохід або обчислювати ці дані ліниво (lazy).

---

## 4. Помилки використання Hooks (React Rules of Hooks)

### Проблема: Умовний виклик хуків
У файлі `app/(tabs)/cocktails/[cocktailId].tsx` виявлено численні порушення правил React (27 помилок за даними ESLint).
- **Деталі**: Після раннього повернення `if (shouldNavigateAway) return null;` (рядок 420) викликаються численні `useEffect`, `useMemo` та `useCallback`.
- **Наслідок**: Це може призводити до непередбачуваної поведінки, помилок рендерингу та проблем з відлагодженням, оскільки порядок виклику хуків змінюється між рендерами.
- **Рішення**: Перенести всі перевірки на раннє повернення **після** виклику всіх хуків, або інкапсулювати логіку в дочірні компоненти.

---

## 5. Структура Коду

### Проблема: Розмір `InventoryProvider`
Файл перевищує 2000 рядків і містить забагато логіки (від бізнес-правил до серіалізації даних).
- **Рішення**: Винести логіку маніпуляції даними (CRUD операції) в окремий хук або набір чистих функцій.

---

## 6. Активи (Assets)
JSON файл з даними (`assets/data/data.json`) має розмір близько 1 МБ.
- **Порада**: Якщо база коктейлів буде зростати, варто розглянути можливість використання SQLite замість завантаження всього JSON в пам'ять.
